#include "sphere.h"void Sphere::buildVertices() {    float x, y, z;    const float PI = acos(-1);    float sec = 2 * PI / sectors;    float sta = PI / stacks;    float theta, phi;        for (int i = 0; i <= stacks; ++i) {        phi = PI / 2 - i * sta;        z = radius * sinf(phi);        for (int j = 0; j <= sectors; ++j) {            theta = j * sec;            x = radius * cosf(theta) * cosf(phi);            y = radius * sinf(theta) * cosf(phi);            positions.push_back(x);            positions.push_back(y);            positions.push_back(z);            normals.push_back(x/radius);            normals.push_back(y/radius);            normals.push_back(z/radius);        }    }    int k1, k2;    for (int i=0; i<stacks; ++i) {        k1 = (sectors + 1) * i;     // start of the stack circle        k2 = k1 + sectors + 1;      // start of the next stack circle        for (int j=0; j<sectors; ++j, ++k1, ++k2) {            if (i != 0) {                indices.push_back(k1);                indices.push_back(k2);                indices.push_back(k1+1);            }            if (i != (stacks - 1)) {                indices.push_back(k1+1);                indices.push_back(k2);                indices.push_back(k2+1);            }        }    }}void Sphere::collideCloth(Mass& m) {    float offset = 0.01f;    if (length(m.position - center) <= radius + offset) {        glm::vec3 correction = normalize(m.position - center) * (radius + offset) + center - m.lastPosition;        m.position = m.lastPosition + (1 - friction) * correction;    }}